# 2 数据结构

## 1 链表

​	用数组模拟单链表的意义在于提高效率

###  1.1 单链表

​	最常用的单链表：邻接表（存储图和树）

​	数组模拟单链表：用e[N]表示值，ne[N]表示指针，以-1表示空集

​	单链表的操作：初始化、插入、删除 

```java
public class Main{
    // 初始化
    public static void init(){
        head = -1;
        idx = 0;
    }
	// 在头节点之前添加节点
    public static void add_to_head(int x){
        e[idx] = x;
        ne[idx] = head;
        head = idx ++;
    }
	// 在第k个节点后添加节点
    public static void add(int k, int x){
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx ++;
    }
	// 删除第k个节点之后的节点
    public static void delete(int k){
        ne[k] = ne[ne[k]];
    }
}
```

### 1.2 双链表

​	用途：优化某些问题

​	特点：双向链表，既有向后的指针，也有向前的指针

```java
// 初始化
    public static void init(){
        idx = 2;
        r[0] = 1;
        l[0] = -1;
        l[1] = 0;
        r[1] = -1;
    }
// 在第k个节点后添加节点
    public static void add(int k, int x){
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = k;
        l[r[k]] = idx;
        r[k] = idx ++;
    }
// 删除第k个节点
    public static void remove(int k){
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
```

##  2 栈与队列

### 2.1 栈

​	栈的特点：先进后出

```java
	public static void push(int x) {
        stack[tt++] = x;
    }
    
    public static void pop() {
        tt--;
    }

    public static boolean isEmpty() {
        return (tt == 0);
    }

    public static int query() {
        return stack[tt - 1];
    }
```

### 2.2 队列

​	队列的特点：先进先出

```java
    public static void init(){
        tt = -1;
        hh = 0;
    }

    public static void push(int x){
        queue[++ tt] = x;  
    }

    public static void pop(){
        hh++;
    }

    public static boolean isEmpty(){
        return (tt < hh);
    }

    public static int query(){
        return queue[hh];
    }
```

### 2.3 单调栈

​	特点：先暴力算法求解，再寻找单调性

```java
        Stack<Integer> stack = new Stack<>();
        
        int n = scanner.nextInt();

        for(int i = 0; i < n; i++){
            int x = scanner.nextInt();

            while(!stack.empty() && stack.peek() >= x)
                stack.pop();
            
            if(!stack.empty())
                System.out.print(stack.peek() + " ");
            else System.out.print("-1 ");

            stack.push(x);
        }
```

### 2.4 单调队列

​	特点：先暴力算法求解，再寻找单调性

```java
String[] str = buffer.readLine().split(" ");
        int n = Integer.parseInt(str[0]), k = Integer.parseInt(str[1]), array[] = new int[n];

        str = buffer.readLine().split(" ");

        init();
            
        for (int i = 0; i < n; i++) {
            array[i] = Integer.parseInt(str[i]);
            // 队列长度固定，队头不能超出队列区间
            if (!isEmpty() && i - k + 1 > query())
                pop();
            // 当前数值 小于 队尾数值时，队尾数值永远不会成为最小值，应该弹出
            while (!isEmpty() && array[queryTail()] > array[i])
                popTail();

            push(i);

            if (i >= k - 1)
                writer.print(array[query()] + " ");
        }

        writer.print('\n');
        init();
        
        for (int i = 0; i < n; i++) {
            // 队列长度固定，队头不能超出队列区间
            if (!isEmpty() && i - k + 1 > query())
                pop();
            // 当前数值 大于 队尾数值时，队尾数值永远不会成为最大值，应该弹出
            while (!isEmpty() && array[queryTail()] < array[i])
                popTail();

            push(i);

            if (i >= k - 1)
                writer.print(array[query()] + " ");
        }
        
        writer.flush();
    }
```

